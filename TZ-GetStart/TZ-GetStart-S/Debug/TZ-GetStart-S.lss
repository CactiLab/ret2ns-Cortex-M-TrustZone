
TZ-GetStart-S.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000095c  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .gnu.sgstubs  00000040  00007c00  00007c00  00027c00  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .relocate     00000004  20000000  0000095c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000001c  20000004  00000960  00020004  2**2
                  ALLOC
  4 .heap         00000200  20000020  0000097c  00020004  2**0
                  ALLOC
  5 .stack        00000400  20000220  00000b7c  00020004  2**0
                  ALLOC
  6 .userRowBlock 00000020  00804000  00804000  00034000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .ARM.attributes 0000002c  00000000  00000000  00034020  2**0
                  CONTENTS, READONLY
  8 .comment      00000059  00000000  00000000  0003404c  2**0
                  CONTENTS, READONLY
  9 .debug_info   00006058  00000000  00000000  000340a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000013b6  00000000  00000000  0003a0fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000928  00000000  00000000  0003b4b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000298  00000000  00000000  0003bddb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c0  00000000  00000000  0003c073  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  00018581  00000000  00000000  0003c233  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000082ef  00000000  00000000  000547b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00088b42  00000000  00000000  0005caa3  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  0000066c  00000000  00000000  000e55e8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
   0:	20 06 00 20 d9 02 00 00 6f 03 00 00 75 03 00 00      .. ....o...u...
	...
  2c:	6f 03 00 00 00 00 00 00 00 00 00 00 6f 03 00 00     o...........o...
  3c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  4c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  5c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  6c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  7c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  8c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  9c:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  ac:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  bc:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  cc:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  dc:	6f 03 00 00 6f 03 00 00 6f 03 00 00 6f 03 00 00     o...o...o...o...
  ec:	6f 03 00 00 6f 03 00 00                             o...o...

000000f4 <__acle_se_nsc_func_plus3>:
#if defined(__ICCARM__) /* IAR EWARM */
__cmse_nonsecure_entry int nsc_func_plus3(int x)
#else /* GCC, Keil MDK with ARM Compiler 6 */
int __attribute__((cmse_nonsecure_entry)) nsc_func_plus3(int x)
#endif
{
  f4:	b580      	push	{r7, lr}
  f6:	b082      	sub	sp, #8
  f8:	af00      	add	r7, sp, #0
  fa:	6078      	str	r0, [r7, #4]
	return func_plus3(x);
  fc:	687b      	ldr	r3, [r7, #4]
  fe:	0018      	movs	r0, r3
 100:	f240 73cd 	movw	r3, #1997	; 0x7cd
 104:	f2c0 0300 	movt	r3, #0
 108:	4798      	blx	r3
 10a:	0003      	movs	r3, r0
}
 10c:	0018      	movs	r0, r3
 10e:	46bd      	mov	sp, r7
 110:	b002      	add	sp, #8
 112:	0001      	movs	r1, r0
 114:	0002      	movs	r2, r0
 116:	0003      	movs	r3, r0
 118:	4684      	mov	ip, r0
 11a:	bc80      	pop	{r7}
 11c:	bc02      	pop	{r1}
 11e:	4686      	mov	lr, r0
 120:	f381 8800 	msr	CPSR_f, r1
 124:	470c      	bxns	r1

00000126 <__acle_se_nsc_func_minus2>:
#if defined(__ICCARM__) /* IAR EWARM */
__cmse_nonsecure_entry int nsc_func_minus2(int x)
#else /* GCC, Keil MDK with ARM Compiler 6 */
int __attribute__((cmse_nonsecure_entry)) nsc_func_minus2(int x)
#endif
{
 126:	b580      	push	{r7, lr}
 128:	b082      	sub	sp, #8
 12a:	af00      	add	r7, sp, #0
 12c:	6078      	str	r0, [r7, #4]
	return func_minus2(x);
 12e:	687b      	ldr	r3, [r7, #4]
 130:	0018      	movs	r0, r3
 132:	f240 73e1 	movw	r3, #2017	; 0x7e1
 136:	f2c0 0300 	movt	r3, #0
 13a:	4798      	blx	r3
 13c:	0003      	movs	r3, r0
}
 13e:	0018      	movs	r0, r3
 140:	46bd      	mov	sp, r7
 142:	b002      	add	sp, #8
 144:	0001      	movs	r1, r0
 146:	0002      	movs	r2, r0
 148:	0003      	movs	r3, r0
 14a:	4684      	mov	ip, r0
 14c:	bc80      	pop	{r7}
 14e:	bc02      	pop	{r1}
 150:	4686      	mov	lr, r0
 152:	f381 8800 	msr	CPSR_f, r1
 156:	470c      	bxns	r1

00000158 <__acle_se_print_nsc>:
#if defined(__ICCARM__) /* IAR EWARM */
__cmse_nonsecure_entry void print_nsc(char* content)
#else /* GCC, Keil MDK with ARM Compiler 6 */
void __attribute__((cmse_nonsecure_entry)) print_nsc(char* content)
#endif
{
 158:	b580      	push	{r7, lr}
 15a:	b082      	sub	sp, #8
 15c:	af00      	add	r7, sp, #0
 15e:	6078      	str	r0, [r7, #4]
	return print_s(content);
 160:	687b      	ldr	r3, [r7, #4]
 162:	0018      	movs	r0, r3
 164:	f640 0333 	movw	r3, #2099	; 0x833
 168:	f2c0 0300 	movt	r3, #0
 16c:	4798      	blx	r3
}
 16e:	46bd      	mov	sp, r7
 170:	b002      	add	sp, #8
 172:	2000      	movs	r0, #0
 174:	0001      	movs	r1, r0
 176:	0002      	movs	r2, r0
 178:	0003      	movs	r3, r0
 17a:	4684      	mov	ip, r0
 17c:	bc80      	pop	{r7}
 17e:	bc01      	pop	{r0}
 180:	4686      	mov	lr, r0
 182:	f380 8800 	msr	CPSR_f, r0
 186:	4704      	bxns	r0

00000188 <__acle_se_print_chk_nsc>:
#if defined(__ICCARM__) /* IAR EWARM */
__cmse_nonsecure_entry void print_chk_nsc(char* content)
#else /* GCC, Keil MDK with ARM Compiler 6 */
void __attribute__((cmse_nonsecure_entry)) print_chk_nsc(char* content)
#endif
{
 188:	b580      	push	{r7, lr}
 18a:	b082      	sub	sp, #8
 18c:	af00      	add	r7, sp, #0
 18e:	6078      	str	r0, [r7, #4]
	return print_and_chk_s(content);
 190:	687b      	ldr	r3, [r7, #4]
 192:	0018      	movs	r0, r3
 194:	f640 0357 	movw	r3, #2135	; 0x857
 198:	f2c0 0300 	movt	r3, #0
 19c:	4798      	blx	r3
}
 19e:	46bd      	mov	sp, r7
 1a0:	b002      	add	sp, #8
 1a2:	2000      	movs	r0, #0
 1a4:	0001      	movs	r1, r0
 1a6:	0002      	movs	r2, r0
 1a8:	0003      	movs	r3, r0
 1aa:	4684      	mov	ip, r0
 1ac:	bc80      	pop	{r7}
 1ae:	bc01      	pop	{r0}
 1b0:	4686      	mov	lr, r0
 1b2:	f380 8800 	msr	CPSR_f, r0
 1b6:	4704      	bxns	r0

000001b8 <default_callback>:


/* ======== Secure callable functions initialization ======== */

void default_callback(void);
void default_callback(void) {
 1b8:	b580      	push	{r7, lr}
 1ba:	af00      	add	r7, sp, #0
	__BKPT(0);
 1bc:	be00      	bkpt	0x0000
	while(1);
 1be:	e7fe      	b.n	1be <default_callback+0x6>

000001c0 <__acle_se_pass_nsfunc_ptr_o_int_i_void>:
#if defined(__ICCARM__) /* IAR EWARM */
__cmse_nonsecure_entry int pass_nsfunc_ptr_o_int_i_void(tdef_nsfunc_o_int_i_void *callback)
#else /* GCC, Keil MDK with ARM Compiler 6 */
int __attribute__((cmse_nonsecure_entry)) pass_nsfunc_ptr_o_int_i_void(tdef_nsfunc_o_int_i_void *callback)
#endif
{
 1c0:	b580      	push	{r7, lr}
 1c2:	b086      	sub	sp, #24
 1c4:	af00      	add	r7, sp, #0
 1c6:	6078      	str	r0, [r7, #4]
 1c8:	687b      	ldr	r3, [r7, #4]
 1ca:	617b      	str	r3, [r7, #20]
#define cmse_TTA_fptr(p) (__cmse_TTA_fptr ((__cmse_fptr)(p)))

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
__cmse_TTA_fptr (__cmse_fptr __p)
__CMSE_TT_ASM (a)
 1cc:	697b      	ldr	r3, [r7, #20]
 1ce:	e843 f380 	tta	r3, r3
 1d2:	60fb      	str	r3, [r7, #12]
 1d4:	68fb      	ldr	r3, [r7, #12]
 1d6:	613b      	str	r3, [r7, #16]
	// Result for the function pointer
	cmse_address_info_t tt_payload;
	tt_payload = cmse_TTA_fptr(callback);
	if (tt_payload.flags.nonsecure_read_ok) {
 1d8:	2312      	movs	r3, #18
 1da:	18fb      	adds	r3, r7, r3
 1dc:	781b      	ldrb	r3, [r3, #0]
 1de:	2210      	movs	r2, #16
 1e0:	4013      	ands	r3, r2
 1e2:	b2db      	uxtb	r3, r3
 1e4:	b153      	cbz	r3, 1fc <__acle_se_pass_nsfunc_ptr_o_int_i_void+0x3c>
		fp = cmse_nsfptr_create(callback); // Non-secure function pointer
 1e6:	687b      	ldr	r3, [r7, #4]
 1e8:	2201      	movs	r2, #1
 1ea:	4393      	bics	r3, r2
 1ec:	001a      	movs	r2, r3
 1ee:	f240 0300 	movw	r3, #0
 1f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 1f6:	601a      	str	r2, [r3, #0]
// 		fp();
		return (0);
 1f8:	2300      	movs	r3, #0
 1fa:	e000      	b.n	1fe <__acle_se_pass_nsfunc_ptr_o_int_i_void+0x3e>
	} else {
		return (1); // Function pointer is not accessible from the Non-secure side
 1fc:	2301      	movs	r3, #1
	}
 1fe:	0018      	movs	r0, r3
 200:	46bd      	mov	sp, r7
 202:	b006      	add	sp, #24
 204:	0001      	movs	r1, r0
 206:	0002      	movs	r2, r0
 208:	0003      	movs	r3, r0
 20a:	4684      	mov	ip, r0
 20c:	bc80      	pop	{r7}
 20e:	bc02      	pop	{r1}
 210:	4686      	mov	lr, r0
 212:	f381 8800 	msr	CPSR_f, r1
 216:	470c      	bxns	r1

00000218 <__do_global_dtors_aux>:
 218:	b510      	push	{r4, lr}
 21a:	f240 0404 	movw	r4, #4
 21e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 222:	7823      	ldrb	r3, [r4, #0]
 224:	b963      	cbnz	r3, 240 <__do_global_dtors_aux+0x28>
 226:	f240 0300 	movw	r3, #0
 22a:	f2c0 0300 	movt	r3, #0
 22e:	b12b      	cbz	r3, 23c <__do_global_dtors_aux+0x24>
 230:	f244 0020 	movw	r0, #16416	; 0x4020
 234:	f2c0 0080 	movt	r0, #128	; 0x80
 238:	e000      	b.n	23c <__do_global_dtors_aux+0x24>
 23a:	bf00      	nop
 23c:	2301      	movs	r3, #1
 23e:	7023      	strb	r3, [r4, #0]
 240:	bd10      	pop	{r4, pc}
 242:	46c0      	nop			; (mov r8, r8)

00000244 <frame_dummy>:
 244:	f240 0300 	movw	r3, #0
 248:	f2c0 0300 	movt	r3, #0
 24c:	b510      	push	{r4, lr}
 24e:	b14b      	cbz	r3, 264 <frame_dummy+0x20>
 250:	f240 0108 	movw	r1, #8
 254:	f244 0020 	movw	r0, #16416	; 0x4020
 258:	f2c2 0100 	movt	r1, #8192	; 0x2000
 25c:	f2c0 0080 	movt	r0, #128	; 0x80
 260:	e000      	b.n	264 <frame_dummy+0x20>
 262:	bf00      	nop
 264:	f244 0020 	movw	r0, #16416	; 0x4020
 268:	f2c0 0080 	movt	r0, #128	; 0x80
 26c:	6803      	ldr	r3, [r0, #0]
 26e:	b903      	cbnz	r3, 272 <frame_dummy+0x2e>
 270:	bd10      	pop	{r4, pc}
 272:	f240 0300 	movw	r3, #0
 276:	f2c0 0300 	movt	r3, #0
 27a:	2b00      	cmp	r3, #0
 27c:	d0f8      	beq.n	270 <frame_dummy+0x2c>
 27e:	4798      	blx	r3
 280:	e7f6      	b.n	270 <frame_dummy+0x2c>
 282:	46c0      	nop			; (mov r8, r8)

00000284 <trustzone_manager_init>:

/**
 * \brief TrustZone Manager Initialization.
 */
static inline void trustzone_manager_init(void)
{
 284:	b580      	push	{r7, lr}
 286:	af00      	add	r7, sp, #0
	/* Setup Port Security Attribution of I/O Pins */
	PORT_SEC->Group[0].NONSEC.reg = CONF_PORT_INIT_NONSEC0_VAL;
 288:	f243 2300 	movw	r3, #12800	; 0x3200
 28c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 290:	2200      	movs	r2, #0
 292:	66da      	str	r2, [r3, #108]	; 0x6c

	/* Setup NVIC Interrupt Target Non-Secure state */
	NVIC->ITNS[0] = CONF_NVIC_INIT_ITNS0_VAL;
 294:	f24e 1300 	movw	r3, #57600	; 0xe100
 298:	f2ce 0300 	movt	r3, #57344	; 0xe000
 29c:	f240 2280 	movw	r2, #640	; 0x280
 2a0:	2100      	movs	r1, #0
 2a2:	5099      	str	r1, [r3, r2]
	NVIC->ITNS[1] = CONF_NVIC_INIT_ITNS1_VAL;
 2a4:	f24e 1300 	movw	r3, #57600	; 0xe100
 2a8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 2ac:	f240 2284 	movw	r2, #644	; 0x284
 2b0:	2100      	movs	r1, #0
 2b2:	5099      	str	r1, [r3, r2]
}
 2b4:	46c0      	nop			; (mov r8, r8)
 2b6:	46bd      	mov	sp, r7
 2b8:	bd80      	pop	{r7, pc}

000002ba <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
 2ba:	b580      	push	{r7, lr}
 2bc:	af00      	add	r7, sp, #0
	system_init();
 2be:	f240 338f 	movw	r3, #911	; 0x38f
 2c2:	f2c0 0300 	movt	r3, #0
 2c6:	4798      	blx	r3
	trustzone_manager_init();
 2c8:	f240 2385 	movw	r3, #645	; 0x285
 2cc:	f2c0 0300 	movt	r3, #0
 2d0:	4798      	blx	r3
}
 2d2:	46c0      	nop			; (mov r8, r8)
 2d4:	46bd      	mov	sp, r7
 2d6:	bd80      	pop	{r7, pc}

000002d8 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
 2d8:	b580      	push	{r7, lr}
 2da:	b082      	sub	sp, #8
 2dc:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
 2de:	f640 135c 	movw	r3, #2396	; 0x95c
 2e2:	f2c0 0300 	movt	r3, #0
 2e6:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
 2e8:	f240 0300 	movw	r3, #0
 2ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 2f0:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
 2f2:	687a      	ldr	r2, [r7, #4]
 2f4:	683b      	ldr	r3, [r7, #0]
 2f6:	429a      	cmp	r2, r3
 2f8:	d00f      	beq.n	31a <Reset_Handler+0x42>
                for (; pDest < &_erelocate;) {
 2fa:	e007      	b.n	30c <Reset_Handler+0x34>
                        *pDest++ = *pSrc++;
 2fc:	683b      	ldr	r3, [r7, #0]
 2fe:	1d1a      	adds	r2, r3, #4
 300:	603a      	str	r2, [r7, #0]
 302:	687a      	ldr	r2, [r7, #4]
 304:	1d11      	adds	r1, r2, #4
 306:	6079      	str	r1, [r7, #4]
 308:	6812      	ldr	r2, [r2, #0]
 30a:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
 30c:	683a      	ldr	r2, [r7, #0]
 30e:	f240 0304 	movw	r3, #4
 312:	f2c2 0300 	movt	r3, #8192	; 0x2000
 316:	429a      	cmp	r2, r3
 318:	d3f0      	bcc.n	2fc <Reset_Handler+0x24>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
 31a:	f240 0304 	movw	r3, #4
 31e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 322:	603b      	str	r3, [r7, #0]
 324:	e004      	b.n	330 <Reset_Handler+0x58>
                *pDest++ = 0;
 326:	683b      	ldr	r3, [r7, #0]
 328:	1d1a      	adds	r2, r3, #4
 32a:	603a      	str	r2, [r7, #0]
 32c:	2200      	movs	r2, #0
 32e:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
 330:	683a      	ldr	r2, [r7, #0]
 332:	f240 0320 	movw	r3, #32
 336:	f2c2 0300 	movt	r3, #8192	; 0x2000
 33a:	429a      	cmp	r2, r3
 33c:	d3f3      	bcc.n	326 <Reset_Handler+0x4e>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
 33e:	f240 0300 	movw	r3, #0
 342:	f2c0 0300 	movt	r3, #0
 346:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 348:	f64e 5300 	movw	r3, #60672	; 0xed00
 34c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 350:	687a      	ldr	r2, [r7, #4]
 352:	217f      	movs	r1, #127	; 0x7f
 354:	438a      	bics	r2, r1
 356:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
 358:	f640 03d9 	movw	r3, #2265	; 0x8d9
 35c:	f2c0 0300 	movt	r3, #0
 360:	4798      	blx	r3

        /* Branch to main function */
        main();
 362:	f240 73f5 	movw	r3, #2037	; 0x7f5
 366:	f2c0 0300 	movt	r3, #0
 36a:	4798      	blx	r3

        /* Infinite loop */
        while (1);
 36c:	e7fe      	b.n	36c <Reset_Handler+0x94>

0000036e <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 36e:	b580      	push	{r7, lr}
 370:	af00      	add	r7, sp, #0
        while (1) {
 372:	e7fe      	b.n	372 <Dummy_Handler+0x4>

00000374 <HardFault_Handler>:

/**
 * \brief Hard fault handler.
 */
void HardFault_Handler(void)
{
 374:	b580      	push	{r7, lr}
 376:	af00      	add	r7, sp, #0
        while (1) {
 378:	e7fe      	b.n	378 <HardFault_Handler+0x4>

0000037a <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
 37a:	b580      	push	{r7, lr}
 37c:	af00      	add	r7, sp, #0
	_init_chip();
 37e:	f240 33c7 	movw	r3, #967	; 0x3c7
 382:	f2c0 0300 	movt	r3, #0
 386:	4798      	blx	r3
}
 388:	46c0      	nop			; (mov r8, r8)
 38a:	46bd      	mov	sp, r7
 38c:	bd80      	pop	{r7, pc}

0000038e <system_init>:
	return 0;
}
#endif

void system_init(void)
{
 38e:	b580      	push	{r7, lr}
 390:	af00      	add	r7, sp, #0
#if (defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U))
	/* Only initialize MCU clock when the project is TrustZone secure project  */
	init_mcu();
 392:	f240 337b 	movw	r3, #891	; 0x37b
 396:	f2c0 0300 	movt	r3, #0
 39a:	4798      	blx	r3
#endif
}
 39c:	46c0      	nop			; (mov r8, r8)
 39e:	46bd      	mov	sp, r7
 3a0:	bd80      	pop	{r7, pc}

000003a2 <hri_nvmctrl_set_CTRLB_RWS_bf>:
	((Nvmctrl *)hw)->CTRLB.reg ^= NVMCTRL_CTRLB_QWEN_Msk;
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
 3a2:	b580      	push	{r7, lr}
 3a4:	b082      	sub	sp, #8
 3a6:	af00      	add	r7, sp, #0
 3a8:	6078      	str	r0, [r7, #4]
 3aa:	6039      	str	r1, [r7, #0]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
 3ac:	687b      	ldr	r3, [r7, #4]
 3ae:	685a      	ldr	r2, [r3, #4]
 3b0:	683b      	ldr	r3, [r7, #0]
 3b2:	005b      	lsls	r3, r3, #1
 3b4:	211e      	movs	r1, #30
 3b6:	400b      	ands	r3, r1
 3b8:	431a      	orrs	r2, r3
 3ba:	687b      	ldr	r3, [r7, #4]
 3bc:	605a      	str	r2, [r3, #4]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
 3be:	46c0      	nop			; (mov r8, r8)
 3c0:	46bd      	mov	sp, r7
 3c2:	b002      	add	sp, #8
 3c4:	bd80      	pop	{r7, pc}

000003c6 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
 3c6:	b580      	push	{r7, lr}
 3c8:	af00      	add	r7, sp, #0
#if (defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U))
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL_SEC, CONF_NVM_WAIT_STATE);
 3ca:	f245 0300 	movw	r3, #20480	; 0x5000
 3ce:	f2c4 1300 	movt	r3, #16640	; 0x4100
 3d2:	2100      	movs	r1, #0
 3d4:	0018      	movs	r0, r3
 3d6:	f240 33a3 	movw	r3, #931	; 0x3a3
 3da:	f2c0 0300 	movt	r3, #0
 3de:	4798      	blx	r3
#else
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
#endif

	_set_performance_level(CONF_PERFORMANCE_LEVEL);
 3e0:	2000      	movs	r0, #0
 3e2:	f240 734b 	movw	r3, #1867	; 0x74b
 3e6:	f2c0 0300 	movt	r3, #0
 3ea:	4798      	blx	r3

	_osc32kctrl_init_sources();
 3ec:	f240 5355 	movw	r3, #1365	; 0x555
 3f0:	f2c0 0300 	movt	r3, #0
 3f4:	4798      	blx	r3
	_oscctrl_init_sources();
 3f6:	f240 6315 	movw	r3, #1557	; 0x615
 3fa:	f2c0 0300 	movt	r3, #0
 3fe:	4798      	blx	r3
	_mclk_init();
 400:	f240 43d5 	movw	r3, #1237	; 0x4d5
 404:	f2c0 0300 	movt	r3, #0
 408:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
 40a:	f240 6369 	movw	r3, #1641	; 0x669
 40e:	f2c0 0300 	movt	r3, #0
 412:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
 414:	201f      	movs	r0, #31
 416:	f240 4381 	movw	r3, #1153	; 0x481
 41a:	f2c0 0300 	movt	r3, #0
 41e:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
 420:	46c0      	nop			; (mov r8, r8)
 422:	46bd      	mov	sp, r7
 424:	bd80      	pop	{r7, pc}

00000426 <hri_gclk_wait_for_sync>:
typedef uint32_t hri_gclk_pchctrl_reg_t;
typedef uint32_t hri_gclk_syncbusy_reg_t;
typedef uint8_t  hri_gclk_ctrla_reg_t;

static inline void hri_gclk_wait_for_sync(const void *const hw, hri_gclk_syncbusy_reg_t reg)
{
 426:	b580      	push	{r7, lr}
 428:	b082      	sub	sp, #8
 42a:	af00      	add	r7, sp, #0
 42c:	6078      	str	r0, [r7, #4]
 42e:	6039      	str	r1, [r7, #0]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
 430:	46c0      	nop			; (mov r8, r8)
 432:	687b      	ldr	r3, [r7, #4]
 434:	685b      	ldr	r3, [r3, #4]
 436:	683a      	ldr	r2, [r7, #0]
 438:	4013      	ands	r3, r2
 43a:	2b00      	cmp	r3, #0
 43c:	d1f9      	bne.n	432 <hri_gclk_wait_for_sync+0xc>
	};
}
 43e:	46c0      	nop			; (mov r8, r8)
 440:	46bd      	mov	sp, r7
 442:	b002      	add	sp, #8
 444:	bd80      	pop	{r7, pc}

00000446 <hri_gclk_write_GENCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
 446:	b580      	push	{r7, lr}
 448:	b084      	sub	sp, #16
 44a:	af00      	add	r7, sp, #0
 44c:	60f8      	str	r0, [r7, #12]
 44e:	607a      	str	r2, [r7, #4]
 450:	230b      	movs	r3, #11
 452:	18fb      	adds	r3, r7, r3
 454:	1c0a      	adds	r2, r1, #0
 456:	701a      	strb	r2, [r3, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
 458:	230b      	movs	r3, #11
 45a:	18fb      	adds	r3, r7, r3
 45c:	781a      	ldrb	r2, [r3, #0]
 45e:	68fb      	ldr	r3, [r7, #12]
 460:	3208      	adds	r2, #8
 462:	0092      	lsls	r2, r2, #2
 464:	6879      	ldr	r1, [r7, #4]
 466:	50d1      	str	r1, [r2, r3]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
 468:	68fb      	ldr	r3, [r7, #12]
 46a:	217d      	movs	r1, #125	; 0x7d
 46c:	0018      	movs	r0, r3
 46e:	f240 4327 	movw	r3, #1063	; 0x427
 472:	f2c0 0300 	movt	r3, #0
 476:	4798      	blx	r3
	GCLK_CRITICAL_SECTION_LEAVE();
}
 478:	46c0      	nop			; (mov r8, r8)
 47a:	46bd      	mov	sp, r7
 47c:	b004      	add	sp, #16
 47e:	bd80      	pop	{r7, pc}

00000480 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_4_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_4_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
 480:	b580      	push	{r7, lr}
 482:	b082      	sub	sp, #8
 484:	af00      	add	r7, sp, #0
 486:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
 488:	687b      	ldr	r3, [r7, #4]
 48a:	2201      	movs	r2, #1
 48c:	4013      	ands	r3, r2
 48e:	b173      	cbz	r3, 4ae <_gclk_init_generators_by_fref+0x2e>
		hri_gclk_write_GENCTRL_reg(
 490:	f240 1205 	movw	r2, #261	; 0x105
 494:	f2c0 0201 	movt	r2, #1
 498:	f641 4300 	movw	r3, #7168	; 0x1c00
 49c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 4a0:	2100      	movs	r1, #0
 4a2:	0018      	movs	r0, r3
 4a4:	f240 4347 	movw	r3, #1095	; 0x447
 4a8:	f2c0 0300 	movt	r3, #0
 4ac:	4798      	blx	r3
		        | (CONF_GCLK_GEN_4_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_4_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_4_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_4_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_4_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_4_SOURCE);
	}
#endif
}
 4ae:	46c0      	nop			; (mov r8, r8)
 4b0:	46bd      	mov	sp, r7
 4b2:	b002      	add	sp, #8
 4b4:	bd80      	pop	{r7, pc}

000004b6 <hri_mclk_write_CPUDIV_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_mclk_write_CPUDIV_reg(const void *const hw, hri_mclk_cpudiv_reg_t data)
{
 4b6:	b580      	push	{r7, lr}
 4b8:	b082      	sub	sp, #8
 4ba:	af00      	add	r7, sp, #0
 4bc:	6078      	str	r0, [r7, #4]
 4be:	000a      	movs	r2, r1
 4c0:	1cfb      	adds	r3, r7, #3
 4c2:	701a      	strb	r2, [r3, #0]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->CPUDIV.reg = data;
 4c4:	687b      	ldr	r3, [r7, #4]
 4c6:	1cfa      	adds	r2, r7, #3
 4c8:	7812      	ldrb	r2, [r2, #0]
 4ca:	711a      	strb	r2, [r3, #4]
	MCLK_CRITICAL_SECTION_LEAVE();
}
 4cc:	46c0      	nop			; (mov r8, r8)
 4ce:	46bd      	mov	sp, r7
 4d0:	b002      	add	sp, #8
 4d2:	bd80      	pop	{r7, pc}

000004d4 <_mclk_init>:

/**
 * \brief Initialize master clock generator
 */
void _mclk_init(void)
{
 4d4:	b580      	push	{r7, lr}
 4d6:	b082      	sub	sp, #8
 4d8:	af00      	add	r7, sp, #0
	void *hw = (void *)MCLK;
 4da:	f640 0300 	movw	r3, #2048	; 0x800
 4de:	f2c4 0300 	movt	r3, #16384	; 0x4000
 4e2:	607b      	str	r3, [r7, #4]
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
 4e4:	687b      	ldr	r3, [r7, #4]
 4e6:	2101      	movs	r1, #1
 4e8:	0018      	movs	r0, r3
 4ea:	f240 43b7 	movw	r3, #1207	; 0x4b7
 4ee:	f2c0 0300 	movt	r3, #0
 4f2:	4798      	blx	r3
}
 4f4:	46c0      	nop			; (mov r8, r8)
 4f6:	46bd      	mov	sp, r7
 4f8:	b002      	add	sp, #8
 4fa:	bd80      	pop	{r7, pc}

000004fc <hri_osc32kctrl_write_RTCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_RTCCTRL_reg(const void *const hw, hri_osc32kctrl_rtcctrl_reg_t data)
{
 4fc:	b580      	push	{r7, lr}
 4fe:	b082      	sub	sp, #8
 500:	af00      	add	r7, sp, #0
 502:	6078      	str	r0, [r7, #4]
 504:	000a      	movs	r2, r1
 506:	1cfb      	adds	r3, r7, #3
 508:	701a      	strb	r2, [r3, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
 50a:	687b      	ldr	r3, [r7, #4]
 50c:	1cfa      	adds	r2, r7, #3
 50e:	7812      	ldrb	r2, [r2, #0]
 510:	741a      	strb	r2, [r3, #16]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
 512:	46c0      	nop			; (mov r8, r8)
 514:	46bd      	mov	sp, r7
 516:	b002      	add	sp, #8
 518:	bd80      	pop	{r7, pc}

0000051a <hri_osc32kctrl_read_OSCULP32K_CALIB_bf>:
	((Osc32kctrl *)hw)->OSCULP32K.reg ^= OSC32KCTRL_OSCULP32K_CALIB(mask);
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
 51a:	b580      	push	{r7, lr}
 51c:	b084      	sub	sp, #16
 51e:	af00      	add	r7, sp, #0
 520:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
 522:	687b      	ldr	r3, [r7, #4]
 524:	69db      	ldr	r3, [r3, #28]
 526:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
 528:	68fb      	ldr	r3, [r7, #12]
 52a:	0a1b      	lsrs	r3, r3, #8
 52c:	221f      	movs	r2, #31
 52e:	4013      	ands	r3, r2
 530:	60fb      	str	r3, [r7, #12]
	return tmp;
 532:	68fb      	ldr	r3, [r7, #12]
}
 534:	0018      	movs	r0, r3
 536:	46bd      	mov	sp, r7
 538:	b004      	add	sp, #16
 53a:	bd80      	pop	{r7, pc}

0000053c <hri_osc32kctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
 53c:	b580      	push	{r7, lr}
 53e:	b082      	sub	sp, #8
 540:	af00      	add	r7, sp, #0
 542:	6078      	str	r0, [r7, #4]
 544:	6039      	str	r1, [r7, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
 546:	687b      	ldr	r3, [r7, #4]
 548:	683a      	ldr	r2, [r7, #0]
 54a:	61da      	str	r2, [r3, #28]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
 54c:	46c0      	nop			; (mov r8, r8)
 54e:	46bd      	mov	sp, r7
 550:	b002      	add	sp, #8
 552:	bd80      	pop	{r7, pc}

00000554 <_osc32kctrl_init_sources>:

/**
 * \brief Initialize 32 kHz clock sources
 */
void _osc32kctrl_init_sources(void)
{
 554:	b580      	push	{r7, lr}
 556:	b082      	sub	sp, #8
 558:	af00      	add	r7, sp, #0
	void *   hw    = (void *)OSC32KCTRL;
 55a:	f241 4300 	movw	r3, #5120	; 0x1400
 55e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 562:	607b      	str	r3, [r7, #4]
	uint16_t calib = 0;
 564:	1cbb      	adds	r3, r7, #2
 566:	2200      	movs	r2, #0
 568:	801a      	strh	r2, [r3, #0]

	hri_osc32kctrl_write_EVCTRL_reg(hw, (CONF_XOSC32K_CFDEO << OSC32KCTRL_EVCTRL_CFDEO_Pos));
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
 56a:	687b      	ldr	r3, [r7, #4]
 56c:	0018      	movs	r0, r3
 56e:	f240 531b 	movw	r3, #1307	; 0x51b
 572:	f2c0 0300 	movt	r3, #0
 576:	4798      	blx	r3
 578:	0002      	movs	r2, r0
 57a:	1cbb      	adds	r3, r7, #2
 57c:	801a      	strh	r2, [r3, #0]
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
 57e:	1cbb      	adds	r3, r7, #2
 580:	881b      	ldrh	r3, [r3, #0]
 582:	021b      	lsls	r3, r3, #8
 584:	001a      	movs	r2, r3
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
 586:	f641 7300 	movw	r3, #7936	; 0x1f00
 58a:	401a      	ands	r2, r3
 58c:	687b      	ldr	r3, [r7, #4]
 58e:	0011      	movs	r1, r2
 590:	0018      	movs	r0, r3
 592:	f240 533d 	movw	r3, #1341	; 0x53d
 596:	f2c0 0300 	movt	r3, #0
 59a:	4798      	blx	r3
	while (!hri_osc32kctrl_get_STATUS_ULP32KSW_bit(hw))
		;
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
 59c:	687b      	ldr	r3, [r7, #4]
 59e:	2100      	movs	r1, #0
 5a0:	0018      	movs	r0, r3
 5a2:	f240 43fd 	movw	r3, #1277	; 0x4fd
 5a6:	f2c0 0300 	movt	r3, #0
 5aa:	4798      	blx	r3
	(void)calib;
}
 5ac:	46c0      	nop			; (mov r8, r8)
 5ae:	46bd      	mov	sp, r7
 5b0:	b002      	add	sp, #8
 5b2:	bd80      	pop	{r7, pc}

000005b4 <hri_oscctrl_get_STATUS_OSC16MRDY_bit>:
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCCKSW_Msk) >> OSCCTRL_STATUS_XOSCCKSW_Pos;
}

static inline bool hri_oscctrl_get_STATUS_OSC16MRDY_bit(const void *const hw)
{
 5b4:	b580      	push	{r7, lr}
 5b6:	b082      	sub	sp, #8
 5b8:	af00      	add	r7, sp, #0
 5ba:	6078      	str	r0, [r7, #4]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC16MRDY_Msk) >> OSCCTRL_STATUS_OSC16MRDY_Pos;
 5bc:	687b      	ldr	r3, [r7, #4]
 5be:	691b      	ldr	r3, [r3, #16]
 5c0:	091b      	lsrs	r3, r3, #4
 5c2:	2201      	movs	r2, #1
 5c4:	4013      	ands	r3, r2
 5c6:	1e5a      	subs	r2, r3, #1
 5c8:	4193      	sbcs	r3, r2
 5ca:	b2db      	uxtb	r3, r3
}
 5cc:	0018      	movs	r0, r3
 5ce:	46bd      	mov	sp, r7
 5d0:	b002      	add	sp, #8
 5d2:	bd80      	pop	{r7, pc}

000005d4 <hri_oscctrl_set_OSC16MCTRL_ONDEMAND_bit>:
	((Oscctrl *)hw)->OSC16MCTRL.reg ^= OSCCTRL_OSC16MCTRL_RUNSTDBY_Msk;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_oscctrl_set_OSC16MCTRL_ONDEMAND_bit(const void *const hw)
{
 5d4:	b580      	push	{r7, lr}
 5d6:	b082      	sub	sp, #8
 5d8:	af00      	add	r7, sp, #0
 5da:	6078      	str	r0, [r7, #4]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ONDEMAND_Msk;
 5dc:	687b      	ldr	r3, [r7, #4]
 5de:	7e1b      	ldrb	r3, [r3, #24]
 5e0:	b2db      	uxtb	r3, r3
 5e2:	2280      	movs	r2, #128	; 0x80
 5e4:	4252      	negs	r2, r2
 5e6:	4313      	orrs	r3, r2
 5e8:	b2da      	uxtb	r2, r3
 5ea:	687b      	ldr	r3, [r7, #4]
 5ec:	761a      	strb	r2, [r3, #24]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
 5ee:	46c0      	nop			; (mov r8, r8)
 5f0:	46bd      	mov	sp, r7
 5f2:	b002      	add	sp, #8
 5f4:	bd80      	pop	{r7, pc}

000005f6 <hri_oscctrl_write_OSC16MCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_OSC16MCTRL_reg(const void *const hw, hri_oscctrl_osc16mctrl_reg_t data)
{
 5f6:	b580      	push	{r7, lr}
 5f8:	b082      	sub	sp, #8
 5fa:	af00      	add	r7, sp, #0
 5fc:	6078      	str	r0, [r7, #4]
 5fe:	000a      	movs	r2, r1
 600:	1cfb      	adds	r3, r7, #3
 602:	701a      	strb	r2, [r3, #0]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC16MCTRL.reg = data;
 604:	687b      	ldr	r3, [r7, #4]
 606:	1cfa      	adds	r2, r7, #3
 608:	7812      	ldrb	r2, [r2, #0]
 60a:	761a      	strb	r2, [r3, #24]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
 60c:	46c0      	nop			; (mov r8, r8)
 60e:	46bd      	mov	sp, r7
 610:	b002      	add	sp, #8
 612:	bd80      	pop	{r7, pc}

00000614 <_oscctrl_init_sources>:

/**
 * \brief Initialize clock sources
 */
void _oscctrl_init_sources(void)
{
 614:	b580      	push	{r7, lr}
 616:	b082      	sub	sp, #8
 618:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
 61a:	f241 0300 	movw	r3, #4096	; 0x1000
 61e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 622:	607b      	str	r3, [r7, #4]

	hri_oscctrl_write_EVCTRL_reg(hw, (CONF_XOSC_CFDEO << OSCCTRL_EVCTRL_CFDEO_Pos));
#endif

#if CONF_OSC16M_CONFIG == 1
	hri_oscctrl_write_OSC16MCTRL_reg(hw,
 624:	687b      	ldr	r3, [r7, #4]
 626:	2102      	movs	r1, #2
 628:	0018      	movs	r0, r3
 62a:	f240 53f7 	movw	r3, #1527	; 0x5f7
 62e:	f2c0 0300 	movt	r3, #0
 632:	4798      	blx	r3
#endif
#endif

#if CONF_OSC16M_CONFIG == 1
#if CONF_OSC16M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC16MRDY_bit(hw))
 634:	46c0      	nop			; (mov r8, r8)
 636:	687b      	ldr	r3, [r7, #4]
 638:	0018      	movs	r0, r3
 63a:	f240 53b5 	movw	r3, #1461	; 0x5b5
 63e:	f2c0 0300 	movt	r3, #0
 642:	4798      	blx	r3
 644:	0003      	movs	r3, r0
 646:	001a      	movs	r2, r3
 648:	2301      	movs	r3, #1
 64a:	4053      	eors	r3, r2
 64c:	b2db      	uxtb	r3, r3
 64e:	2b00      	cmp	r3, #0
 650:	d1f1      	bne.n	636 <_oscctrl_init_sources+0x22>
		;
#endif
#if CONF_OSC16M_ONDEMAND == 1
	hri_oscctrl_set_OSC16MCTRL_ONDEMAND_bit(hw);
 652:	687b      	ldr	r3, [r7, #4]
 654:	0018      	movs	r0, r3
 656:	f240 53d5 	movw	r3, #1493	; 0x5d5
 65a:	f2c0 0300 	movt	r3, #0
 65e:	4798      	blx	r3
#endif
#endif
	(void)hw;
}
 660:	46c0      	nop			; (mov r8, r8)
 662:	46bd      	mov	sp, r7
 664:	b002      	add	sp, #8
 666:	bd80      	pop	{r7, pc}

00000668 <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
 668:	b580      	push	{r7, lr}
 66a:	b082      	sub	sp, #8
 66c:	af00      	add	r7, sp, #0
	void *                        hw  = (void *)OSCCTRL;
 66e:	f241 0300 	movw	r3, #4096	; 0x1000
 672:	f2c4 0300 	movt	r3, #16384	; 0x4000
 676:	607b      	str	r3, [r7, #4]
	hri_oscctrl_dfllulpctrl_reg_t tmp = 0;
 678:	1cbb      	adds	r3, r7, #2
 67a:	2200      	movs	r2, #0
 67c:	801a      	strh	r2, [r3, #0]
#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
		;
#endif
	(void)hw, (void)tmp;
}
 67e:	46c0      	nop			; (mov r8, r8)
 680:	46bd      	mov	sp, r7
 682:	b002      	add	sp, #8
 684:	bd80      	pop	{r7, pc}

00000686 <hri_pm_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_pm_intflag_reg_t hri_pm_read_INTFLAG_reg(const void *const hw)
{
 686:	b580      	push	{r7, lr}
 688:	b082      	sub	sp, #8
 68a:	af00      	add	r7, sp, #0
 68c:	6078      	str	r0, [r7, #4]
	return ((Pm *)hw)->INTFLAG.reg;
 68e:	687b      	ldr	r3, [r7, #4]
 690:	799b      	ldrb	r3, [r3, #6]
 692:	b2db      	uxtb	r3, r3
}
 694:	0018      	movs	r0, r3
 696:	46bd      	mov	sp, r7
 698:	b002      	add	sp, #8
 69a:	bd80      	pop	{r7, pc}

0000069c <hri_pm_clear_INTFLAG_reg>:

static inline void hri_pm_clear_INTFLAG_reg(const void *const hw, hri_pm_intflag_reg_t mask)
{
 69c:	b580      	push	{r7, lr}
 69e:	b082      	sub	sp, #8
 6a0:	af00      	add	r7, sp, #0
 6a2:	6078      	str	r0, [r7, #4]
 6a4:	000a      	movs	r2, r1
 6a6:	1cfb      	adds	r3, r7, #3
 6a8:	701a      	strb	r2, [r3, #0]
	((Pm *)hw)->INTFLAG.reg = mask;
 6aa:	687b      	ldr	r3, [r7, #4]
 6ac:	1cfa      	adds	r2, r7, #3
 6ae:	7812      	ldrb	r2, [r2, #0]
 6b0:	719a      	strb	r2, [r3, #6]
}
 6b2:	46c0      	nop			; (mov r8, r8)
 6b4:	46bd      	mov	sp, r7
 6b6:	b002      	add	sp, #8
 6b8:	bd80      	pop	{r7, pc}

000006ba <hri_pm_get_PLCFG_PLSEL_bf>:
	((Pm *)hw)->PLCFG.reg |= PM_PLCFG_PLSEL(mask);
	PM_CRITICAL_SECTION_LEAVE();
}

static inline hri_pm_plcfg_reg_t hri_pm_get_PLCFG_PLSEL_bf(const void *const hw, hri_pm_plcfg_reg_t mask)
{
 6ba:	b580      	push	{r7, lr}
 6bc:	b084      	sub	sp, #16
 6be:	af00      	add	r7, sp, #0
 6c0:	6078      	str	r0, [r7, #4]
 6c2:	000a      	movs	r2, r1
 6c4:	1cfb      	adds	r3, r7, #3
 6c6:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	tmp = ((Pm *)hw)->PLCFG.reg;
 6c8:	230f      	movs	r3, #15
 6ca:	18fb      	adds	r3, r7, r3
 6cc:	687a      	ldr	r2, [r7, #4]
 6ce:	7892      	ldrb	r2, [r2, #2]
 6d0:	701a      	strb	r2, [r3, #0]
	tmp = (tmp & PM_PLCFG_PLSEL(mask)) >> PM_PLCFG_PLSEL_Pos;
 6d2:	230f      	movs	r3, #15
 6d4:	18fb      	adds	r3, r7, r3
 6d6:	1cfa      	adds	r2, r7, #3
 6d8:	781b      	ldrb	r3, [r3, #0]
 6da:	7812      	ldrb	r2, [r2, #0]
 6dc:	4013      	ands	r3, r2
 6de:	b2da      	uxtb	r2, r3
 6e0:	230f      	movs	r3, #15
 6e2:	18fb      	adds	r3, r7, r3
 6e4:	2103      	movs	r1, #3
 6e6:	400a      	ands	r2, r1
 6e8:	701a      	strb	r2, [r3, #0]
	return tmp;
 6ea:	230f      	movs	r3, #15
 6ec:	18fb      	adds	r3, r7, r3
 6ee:	781b      	ldrb	r3, [r3, #0]
}
 6f0:	0018      	movs	r0, r3
 6f2:	46bd      	mov	sp, r7
 6f4:	b004      	add	sp, #16
 6f6:	bd80      	pop	{r7, pc}

000006f8 <hri_pm_write_PLCFG_PLSEL_bf>:

static inline void hri_pm_write_PLCFG_PLSEL_bf(const void *const hw, hri_pm_plcfg_reg_t data)
{
 6f8:	b580      	push	{r7, lr}
 6fa:	b084      	sub	sp, #16
 6fc:	af00      	add	r7, sp, #0
 6fe:	6078      	str	r0, [r7, #4]
 700:	000a      	movs	r2, r1
 702:	1cfb      	adds	r3, r7, #3
 704:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PM_CRITICAL_SECTION_ENTER();
	tmp = ((Pm *)hw)->PLCFG.reg;
 706:	230f      	movs	r3, #15
 708:	18fb      	adds	r3, r7, r3
 70a:	687a      	ldr	r2, [r7, #4]
 70c:	7892      	ldrb	r2, [r2, #2]
 70e:	701a      	strb	r2, [r3, #0]
	tmp &= ~PM_PLCFG_PLSEL_Msk;
 710:	230f      	movs	r3, #15
 712:	18fb      	adds	r3, r7, r3
 714:	220f      	movs	r2, #15
 716:	18ba      	adds	r2, r7, r2
 718:	7812      	ldrb	r2, [r2, #0]
 71a:	2103      	movs	r1, #3
 71c:	438a      	bics	r2, r1
 71e:	701a      	strb	r2, [r3, #0]
	tmp |= PM_PLCFG_PLSEL(data);
 720:	1cfb      	adds	r3, r7, #3
 722:	781b      	ldrb	r3, [r3, #0]
 724:	2203      	movs	r2, #3
 726:	4013      	ands	r3, r2
 728:	b2d9      	uxtb	r1, r3
 72a:	230f      	movs	r3, #15
 72c:	18fb      	adds	r3, r7, r3
 72e:	220f      	movs	r2, #15
 730:	18ba      	adds	r2, r7, r2
 732:	7812      	ldrb	r2, [r2, #0]
 734:	430a      	orrs	r2, r1
 736:	701a      	strb	r2, [r3, #0]
	((Pm *)hw)->PLCFG.reg = tmp;
 738:	687b      	ldr	r3, [r7, #4]
 73a:	220f      	movs	r2, #15
 73c:	18ba      	adds	r2, r7, r2
 73e:	7812      	ldrb	r2, [r2, #0]
 740:	709a      	strb	r2, [r3, #2]
	PM_CRITICAL_SECTION_LEAVE();
}
 742:	46c0      	nop			; (mov r8, r8)
 744:	46bd      	mov	sp, r7
 746:	b004      	add	sp, #16
 748:	bd80      	pop	{r7, pc}

0000074a <_set_performance_level>:

/**
 * \brief Set performance level
 */
void _set_performance_level(const uint8_t level)
{
 74a:	b580      	push	{r7, lr}
 74c:	b082      	sub	sp, #8
 74e:	af00      	add	r7, sp, #0
 750:	0002      	movs	r2, r0
 752:	1dfb      	adds	r3, r7, #7
 754:	701a      	strb	r2, [r3, #0]
	if (hri_pm_get_PLCFG_PLSEL_bf(PM, PM_PLCFG_PLSEL_Msk) != level) {
 756:	f240 4300 	movw	r3, #1024	; 0x400
 75a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 75e:	2103      	movs	r1, #3
 760:	0018      	movs	r0, r3
 762:	f240 63bb 	movw	r3, #1723	; 0x6bb
 766:	f2c0 0300 	movt	r3, #0
 76a:	4798      	blx	r3
 76c:	0003      	movs	r3, r0
 76e:	001a      	movs	r2, r3
 770:	1dfb      	adds	r3, r7, #7
 772:	781b      	ldrb	r3, [r3, #0]
 774:	4293      	cmp	r3, r2
 776:	d025      	beq.n	7c4 <_set_performance_level+0x7a>
		hri_pm_clear_INTFLAG_reg(PM, 0xFF);
 778:	f240 4300 	movw	r3, #1024	; 0x400
 77c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 780:	21ff      	movs	r1, #255	; 0xff
 782:	0018      	movs	r0, r3
 784:	f240 639d 	movw	r3, #1693	; 0x69d
 788:	f2c0 0300 	movt	r3, #0
 78c:	4798      	blx	r3
		hri_pm_write_PLCFG_PLSEL_bf(PM, level);
 78e:	1dfb      	adds	r3, r7, #7
 790:	781a      	ldrb	r2, [r3, #0]
 792:	f240 4300 	movw	r3, #1024	; 0x400
 796:	f2c4 0300 	movt	r3, #16384	; 0x4000
 79a:	0011      	movs	r1, r2
 79c:	0018      	movs	r0, r3
 79e:	f240 63f9 	movw	r3, #1785	; 0x6f9
 7a2:	f2c0 0300 	movt	r3, #0
 7a6:	4798      	blx	r3
		while (!hri_pm_read_INTFLAG_reg(PM))
 7a8:	46c0      	nop			; (mov r8, r8)
 7aa:	f240 4300 	movw	r3, #1024	; 0x400
 7ae:	f2c4 0300 	movt	r3, #16384	; 0x4000
 7b2:	0018      	movs	r0, r3
 7b4:	f240 6387 	movw	r3, #1671	; 0x687
 7b8:	f2c0 0300 	movt	r3, #0
 7bc:	4798      	blx	r3
 7be:	0003      	movs	r3, r0
 7c0:	2b00      	cmp	r3, #0
 7c2:	d0f2      	beq.n	7aa <_set_performance_level+0x60>
			;
	}
}
 7c4:	46c0      	nop			; (mov r8, r8)
 7c6:	46bd      	mov	sp, r7
 7c8:	b002      	add	sp, #8
 7ca:	bd80      	pop	{r7, pc}

000007cc <func_plus3>:

/**
 * \brief This function will return a value of input parameter plus three.
 */
int func_plus3(int x)
{
 7cc:	b580      	push	{r7, lr}
 7ce:	b082      	sub	sp, #8
 7d0:	af00      	add	r7, sp, #0
 7d2:	6078      	str	r0, [r7, #4]
	return x + 3;
 7d4:	687b      	ldr	r3, [r7, #4]
 7d6:	3303      	adds	r3, #3
}
 7d8:	0018      	movs	r0, r3
 7da:	46bd      	mov	sp, r7
 7dc:	b002      	add	sp, #8
 7de:	bd80      	pop	{r7, pc}

000007e0 <func_minus2>:

/**
 * \brief This function will return a value of input parameter minus two.
 */
int func_minus2(int x)
{
 7e0:	b580      	push	{r7, lr}
 7e2:	b082      	sub	sp, #8
 7e4:	af00      	add	r7, sp, #0
 7e6:	6078      	str	r0, [r7, #4]
	return x - 2;
 7e8:	687b      	ldr	r3, [r7, #4]
 7ea:	3b02      	subs	r3, #2
}
 7ec:	0018      	movs	r0, r3
 7ee:	46bd      	mov	sp, r7
 7f0:	b002      	add	sp, #8
 7f2:	bd80      	pop	{r7, pc}

000007f4 <main>:
 * - Sets the non-secure main stack (MSP_NS)
 * - Gets the non-secure reset handler
 * - Jumps to the non-secure software application
 */
int main(void)
{
 7f4:	b590      	push	{r4, r7, lr}
 7f6:	b083      	sub	sp, #12
 7f8:	af00      	add	r7, sp, #0
	funcptr_void NonSecure_ResetHandler;

	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 7fa:	f240 23bb 	movw	r3, #699	; 0x2bb
 7fe:	f2c0 0300 	movt	r3, #0
 802:	4798      	blx	r3

	/* Set non-secure main stack (MSP_NS) */
	__TZ_set_MSP_NS(*((uint32_t *)(CONF_TZ_START_NS)));
 804:	f248 0300 	movw	r3, #32768	; 0x8000
 808:	681b      	ldr	r3, [r3, #0]
 80a:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 80c:	683b      	ldr	r3, [r7, #0]
 80e:	f383 8888 	msr	MSP_NS, r3

	/* Get non-secure reset handler */
	NonSecure_ResetHandler = (funcptr_void)(*((uint32_t *)((CONF_TZ_START_NS) + 4U)));
 812:	f248 0304 	movw	r3, #32772	; 0x8004
 816:	681b      	ldr	r3, [r3, #0]
 818:	607b      	str	r3, [r7, #4]
	
	/* Start non-secure state software application */
	NonSecure_ResetHandler();
 81a:	687b      	ldr	r3, [r7, #4]
 81c:	001c      	movs	r4, r3
 81e:	0864      	lsrs	r4, r4, #1
 820:	0064      	lsls	r4, r4, #1
 822:	0020      	movs	r0, r4
 824:	0021      	movs	r1, r4
 826:	0022      	movs	r2, r4
 828:	0023      	movs	r3, r4
 82a:	f000 f83c 	bl	8a6 <__gnu_cmse_nonsecure_call>

	/* Replace with your application code */
	while (1) {
		__NOP();
 82e:	46c0      	nop			; (mov r8, r8)
 830:	e7fd      	b.n	82e <main+0x3a>

00000832 <print_s>:

#include "ret2nw_s.h"


void print_s(char* input)
{
 832:	b580      	push	{r7, lr}
 834:	b084      	sub	sp, #16
 836:	af00      	add	r7, sp, #0
 838:	6078      	str	r0, [r7, #4]
	char buf[4];
	memcpy(buf, input, 32);
 83a:	6879      	ldr	r1, [r7, #4]
 83c:	230c      	movs	r3, #12
 83e:	18fb      	adds	r3, r7, r3
 840:	2220      	movs	r2, #32
 842:	0018      	movs	r0, r3
 844:	f640 1329 	movw	r3, #2345	; 0x929
 848:	f2c0 0300 	movt	r3, #0
 84c:	4798      	blx	r3
	return;
 84e:	46c0      	nop			; (mov r8, r8)
}
 850:	46bd      	mov	sp, r7
 852:	b004      	add	sp, #16
 854:	bd80      	pop	{r7, pc}

00000856 <print_and_chk_s>:

typedef int __attribute__((cmse_nonsecure_call)) chk_func_ptr(void);
void print_and_chk_s(char* input)
{
 856:	b590      	push	{r4, r7, lr}
 858:	b087      	sub	sp, #28
 85a:	af00      	add	r7, sp, #0
 85c:	6078      	str	r0, [r7, #4]
	int driver_status;
	chk_func_ptr *check_fp;
	check_fp = cmse_nsfptr_create(fp);
 85e:	f240 0300 	movw	r3, #0
 862:	f2c2 0300 	movt	r3, #8192	; 0x2000
 866:	681b      	ldr	r3, [r3, #0]
 868:	001a      	movs	r2, r3
 86a:	2301      	movs	r3, #1
 86c:	439a      	bics	r2, r3
 86e:	0013      	movs	r3, r2
 870:	617b      	str	r3, [r7, #20]
 	char buf[4];
 	memcpy(buf, input, 12);
 872:	6879      	ldr	r1, [r7, #4]
 874:	230c      	movs	r3, #12
 876:	18fb      	adds	r3, r7, r3
 878:	220c      	movs	r2, #12
 87a:	0018      	movs	r0, r3
 87c:	f640 1329 	movw	r3, #2345	; 0x929
 880:	f2c0 0300 	movt	r3, #0
 884:	4798      	blx	r3
	driver_status = check_fp();
 886:	697b      	ldr	r3, [r7, #20]
 888:	001c      	movs	r4, r3
 88a:	0864      	lsrs	r4, r4, #1
 88c:	0064      	lsls	r4, r4, #1
 88e:	0020      	movs	r0, r4
 890:	0021      	movs	r1, r4
 892:	0022      	movs	r2, r4
 894:	0023      	movs	r3, r4
 896:	f000 f806 	bl	8a6 <__gnu_cmse_nonsecure_call>
 89a:	0003      	movs	r3, r0
 89c:	613b      	str	r3, [r7, #16]
	if (driver_status == 0) {
		// do something...	
	}
	return;
 89e:	46c0      	nop			; (mov r8, r8)
 8a0:	46bd      	mov	sp, r7
 8a2:	b007      	add	sp, #28
 8a4:	bd90      	pop	{r4, r7, pc}

000008a6 <__gnu_cmse_nonsecure_call>:
 8a6:	b5e0      	push	{r5, r6, r7, lr}
 8a8:	4645      	mov	r5, r8
 8aa:	464e      	mov	r6, r9
 8ac:	4657      	mov	r7, sl
 8ae:	b4e0      	push	{r5, r6, r7}
 8b0:	465d      	mov	r5, fp
 8b2:	b420      	push	{r5}
 8b4:	4625      	mov	r5, r4
 8b6:	4626      	mov	r6, r4
 8b8:	4627      	mov	r7, r4
 8ba:	46a0      	mov	r8, r4
 8bc:	46a1      	mov	r9, r4
 8be:	46a2      	mov	sl, r4
 8c0:	46a3      	mov	fp, r4
 8c2:	46a4      	mov	ip, r4
 8c4:	f384 8800 	msr	CPSR_f, r4
 8c8:	47a4      	blxns	r4
 8ca:	bc20      	pop	{r5}
 8cc:	46ab      	mov	fp, r5
 8ce:	bce0      	pop	{r5, r6, r7}
 8d0:	46ba      	mov	sl, r7
 8d2:	46b1      	mov	r9, r6
 8d4:	46a8      	mov	r8, r5
 8d6:	bde0      	pop	{r5, r6, r7, pc}

000008d8 <__libc_init_array>:
 8d8:	b570      	push	{r4, r5, r6, lr}
 8da:	2500      	movs	r5, #0
 8dc:	4b0e      	ldr	r3, [pc, #56]	; (918 <__libc_init_array+0x40>)
 8de:	4c0f      	ldr	r4, [pc, #60]	; (91c <__libc_init_array+0x44>)
 8e0:	1ae4      	subs	r4, r4, r3
 8e2:	10a4      	asrs	r4, r4, #2
 8e4:	42a5      	cmp	r5, r4
 8e6:	d109      	bne.n	8fc <__libc_init_array+0x24>
 8e8:	2500      	movs	r5, #0
 8ea:	f000 f827 	bl	93c <_init>
 8ee:	4c0c      	ldr	r4, [pc, #48]	; (920 <__libc_init_array+0x48>)
 8f0:	4b0c      	ldr	r3, [pc, #48]	; (924 <__libc_init_array+0x4c>)
 8f2:	1ae4      	subs	r4, r4, r3
 8f4:	10a4      	asrs	r4, r4, #2
 8f6:	42a5      	cmp	r5, r4
 8f8:	d107      	bne.n	90a <__libc_init_array+0x32>
 8fa:	bd70      	pop	{r4, r5, r6, pc}
 8fc:	4a06      	ldr	r2, [pc, #24]	; (918 <__libc_init_array+0x40>)
 8fe:	00ab      	lsls	r3, r5, #2
 900:	189b      	adds	r3, r3, r2
 902:	681b      	ldr	r3, [r3, #0]
 904:	4798      	blx	r3
 906:	3501      	adds	r5, #1
 908:	e7ec      	b.n	8e4 <__libc_init_array+0xc>
 90a:	4a06      	ldr	r2, [pc, #24]	; (924 <__libc_init_array+0x4c>)
 90c:	00ab      	lsls	r3, r5, #2
 90e:	189b      	adds	r3, r3, r2
 910:	681b      	ldr	r3, [r3, #0]
 912:	4798      	blx	r3
 914:	3501      	adds	r5, #1
 916:	e7ee      	b.n	8f6 <__libc_init_array+0x1e>
 918:	00000948 	.word	0x00000948
 91c:	00000948 	.word	0x00000948
 920:	0000094c 	.word	0x0000094c
 924:	00000948 	.word	0x00000948

00000928 <memcpy>:
 928:	2300      	movs	r3, #0
 92a:	b510      	push	{r4, lr}
 92c:	429a      	cmp	r2, r3
 92e:	d100      	bne.n	932 <memcpy+0xa>
 930:	bd10      	pop	{r4, pc}
 932:	5ccc      	ldrb	r4, [r1, r3]
 934:	54c4      	strb	r4, [r0, r3]
 936:	3301      	adds	r3, #1
 938:	e7f8      	b.n	92c <memcpy+0x4>
	...

0000093c <_init>:
 93c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 93e:	46c0      	nop			; (mov r8, r8)
 940:	bcf8      	pop	{r3, r4, r5, r6, r7}
 942:	bc08      	pop	{r3}
 944:	469e      	mov	lr, r3
 946:	4770      	bx	lr

00000948 <__init_array_start>:
 948:	00000245 	.word	0x00000245

0000094c <_fini>:
 94c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 94e:	46c0      	nop			; (mov r8, r8)
 950:	bcf8      	pop	{r3, r4, r5, r6, r7}
 952:	bc08      	pop	{r3}
 954:	469e      	mov	lr, r3
 956:	4770      	bx	lr

00000958 <__fini_array_start>:
 958:	00000219 	.word	0x00000219

Disassembly of section .gnu.sgstubs:

00007c00 <nsc_func_plus3>:
    7c00:	e97f e97f 	sg
    7c04:	f7f8 ba76 	b.w	f4 <__acle_se_nsc_func_plus3>

00007c08 <nsc_func_minus2>:
    7c08:	e97f e97f 	sg
    7c0c:	f7f8 ba8b 	b.w	126 <__acle_se_nsc_func_minus2>

00007c10 <pass_nsfunc_ptr_o_int_i_void>:
    7c10:	e97f e97f 	sg
    7c14:	f7f8 bad4 	b.w	1c0 <__acle_se_pass_nsfunc_ptr_o_int_i_void>

00007c18 <print_chk_nsc>:
    7c18:	e97f e97f 	sg
    7c1c:	f7f8 bab4 	b.w	188 <__acle_se_print_chk_nsc>

00007c20 <print_nsc>:
    7c20:	e97f e97f 	sg
    7c24:	f7f8 ba98 	b.w	158 <__acle_se_print_nsc>
	...
